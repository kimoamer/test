<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900 text-white">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Location Trust Analyzer (Lite) Test</title>
    <!-- Using Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
        }
        .result-box {
            background-color: #1a202c; /* A slightly lighter dark shade */
            font-family: 'Courier New', Courier, monospace;
            transition: all 0.3s ease;
        }
        .result-box.high-risk {
            border-color: #e53e3e; /* red-500 */
            box-shadow: 0 0 15px rgba(229, 62, 62, 0.5);
        }
        .result-box.medium-risk {
            border-color: #f6e05e; /* yellow-300 */
            box-shadow: 0 0 15px rgba(246, 224, 94, 0.3);
        }
        .result-box.low-risk {
            border-color: #48bb78; /* green-500 */
        }
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="h-full flex items-center justify-center p-4">

    <div class="w-full max-w-2xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-3xl font-bold text-blue-400">Location Trust Analyzer</h1>
            <p class="text-lg text-gray-400">Client-Side "Lite" Version Test (v3)</p>
            <p class="text-sm text-gray-500 mt-2">
                This test only runs device-level checks (GPS anomalies, speed, etc.).
                It cannot detect VPNs or Proxies.
            </p>
        </header>

        <!-- Control Button -->
        <div class="text-center mb-6">
            <button id="runTestButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:scale-105">
                Start Location Analysis
            </button>
        </div>

        <!-- Results Area -->
        <div id="resultsContainer" class="hidden">
            <!-- Loader -->
            <div id="loader" class="flex flex-col items-center justify-center h-48 p-4 bg-gray-800 rounded-lg shadow-inner">
                <p class="text-lg font-semibold text-blue-300 mb-3">Waiting for Location Permission...</p>
                <p class="text-center text-gray-400 mb-4">Your browser will ask you to "Allow" location access. Please approve it to run the analysis.</p>
                <div class="loader"></div>
                <p class="text-sm text-gray-500 mt-4">(This may take up to 20 seconds)</p>
            </div>

            <!-- Error Message -->
            <div id="errorMessage" class="hidden p-4 bg-red-800 border border-red-600 rounded-lg text-white">
                <h3 class="font-bold mb-2">Analysis Failed</h3>
                <p id="errorText"></p>
            </div>

            <!-- Success Results -->
            <div id="successResults" class="hidden">
                <!-- Score & Flags -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div class="bg-gray-800 p-4 rounded-lg shadow-md">
                        <h3 class="text-sm font-semibold text-gray-400 uppercase mb-2">Trust Score</h3>
                        <p id="score" class="text-5xl font-bold text-center">-</p>
                        <p id="scoreDescription" class="text-center text-gray-400 text-sm mt-1">-</p>
                    </div>
                    <div class="bg-gray-800 p-4 rounded-lg shadow-md">
                        <h3 class="text-sm font-semibold text-gray-400 uppercase mb-2">Triggered Flags</h3>
                        <ul id="flagsList" class="h-24 overflow-y-auto">
                            <!-- Flags will be populated here -->
                        </ul>
                    </div>
                </div>

                <!-- Full Report -->
                <div>
                    <h3 class="text-sm font-semibold text-gray-400 uppercase mb-2">Full Report (JSON)</h3>
                    <pre id="fullReport" class="result-box p-4 rounded-lg overflow-x-auto text-sm border-2 border-gray-700"></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- 
      ==================================================================
      SCRIPT: LocationTrustAnalyzer-Lite.js
      ==================================================================
    -->
    <script>
        /**
         * LocationTrustAnalyzer-Lite.js
         * v3: Calibrated to reduce false positives on good, real GPS signals.
         */
        class LocationTrustAnalyzerLite {
            constructor() {
                this.locationOptions = {
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 20000
                };
                this.EARTH_RADIUS_KM = 6371;
                this.riskWeights = {
                    FLAG_IMPOSSIBLE_TRAVEL: 50,
                    FLAG_STATIC_ACCURACY_WARMUP: 25,
                    FLAG_SPEED_CONTRADICTION: 20,
                    FLAG_PERFECT_ACCURACY: 15,
                    FLAG_TIMEZONE_MISMATCH: 15,
                    FLAG_TIMESTAMP_STALE: 10,
                    FLAG_LANGUAGE_MISMATCH: 5,
                    FLAG_ERROR_ANALYSIS_FAILED: 100,
                    FLAG_ERROR_PERMISSION_DENIED: 100,
                    FLAG_ERROR_TIMEOUT: 75,
                    FLAG_ERROR_POSITION_UNAVAILABLE: 80,
                    FLAG_ERROR_GEOLOCATION_UNSUPPORTED: 100
                };
            }

            _createError(message, code) {
                const error = new Error(message);
                error.code = code;
                return error;
            }

            async checkLocationTrust() {
                const flags = [];
                let report = {};

                try {
                    const deviceData = await this._getDeviceHeuristics();
                    report.deviceData = deviceData;
                    flags.push(...deviceData.flags);

                    const crossFlags = this._getCrossValidationSignals(deviceData.position);
                    flags.push(...crossFlags);
                    report.crossFlags = crossFlags;

                    const score = this._calculateTrustScore(flags);
                    report.finalScore = score;
                    report.finalFlags = [...new Set(flags)];
                    
                    return { score, flags: report.finalFlags, data: report };

                } catch (error) {
                    console.error('LocationTrustAnalyzer-Lite Error:', error.message, `(Code: ${error.code})`);
                    
                    let errorFlag = 'FLAG_ERROR_ANALYSIS_FAILED';
                    if (error.code === 1) errorFlag = 'FLAG_ERROR_PERMISSION_DENIED';
                    if (error.code === 2) errorFlag = 'FLAG_ERROR_POSITION_UNAVAILABLE';
                    if (error.code === 3) errorFlag = 'FLAG_ERROR_TIMEOUT';
                    if (error.code === -1) errorFlag = 'FLAG_ERROR_GEOLOCATION_UNSUPPORTED';

                    
                    const score = this.riskWeights[errorFlag] || 100;
                    return { score, flags: [errorFlag], data: { error: error.message, code: error.code } };
                }
            }

            async _getDeviceHeuristics() {
                const positions = await this._getWatchedPositions(5);
                if (!positions || positions.length === 0) {
                    throw this._createError('Could not retrieve device location.', -2);
                }

                const firstPos = positions[0];
                const lastPos = positions[positions.length - 1];
                const deviceFlags = [];
                
                const accuracies = positions.map(p => p.coords.accuracy);
                
                // *** CALIBRATION CHANGE 1 ***
                // We ONLY flag static accuracy if *all* readings are identical.
                // This is a much stronger signal of a fake location.
                const accuracyStdDev = this._calculateStdDev(accuracies);
                if (accuracies.length > 3 && accuracyStdDev === 0) {
                    deviceFlags.push('FLAG_STATIC_ACCURACY_WARMUP');
                }

                // *** CALIBRATION CHANGE 2 ***
                // REMOVED the `accuracies[0] < 100` check.
                // This was causing false positives on good, real GPS/Wi-Fi locks.

                // *** CALIBRATION CHANGE 3 ***
                // Tuned to be less sensitive to good GPS and more sensitive to "perfect" fakes.
                // Now flags < 5m (was < 10m) or a suspiciously round integer under 50.
                if (lastPos.coords.accuracy < 5 || (lastPos.coords.accuracy % 1 === 0 && lastPos.coords.accuracy > 0 && lastPos.coords.accuracy < 50)) {
                    deviceFlags.push('FLAG_PERFECT_ACCURACY');
                }


                if (positions.length > 1) {
                    const distance = this._haversine(firstPos.coords, lastPos.coords);
                    const timeDelta = (lastPos.timestamp - firstPos.timestamp) / 1000;
                    
                    if (timeDelta > 0) {
                        const calcVelocity = distance / timeDelta;
                        if (calcVelocity > 343) { // Faster than speed of sound
                            deviceFlags.push('FLAG_IMPOSSIBLE_TRAVEL');
                        }
                        const reportedSpeed = lastPos.coords.speed;
                        if (calcVelocity > 5 && (reportedSpeed === 0 || reportedSpeed === null)) {
                            // You moved > 5 m/s (walking speed) but your device reports 0 speed
                            deviceFlags.push('FLAG_SPEED_CONTRADICTION');
                        }
                    }
                }
                
                const age = Date.now() - lastPos.timestamp;
                if (age > 1000 * 60 * 5) { // Location is older than 5 minutes
                    deviceFlags.push('FLAG_TIMESTAMP_STALE');
                }

                return { position: lastPos, flags: [...new Set(deviceFlags)] };
            }

            _getCrossValidationSignals(devicePosition) {
                const flags = [];
                try {
                    const systemZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                    if (!systemZone) {
                        flags.push('FLAG_TIMEZONE_MISMATCH');
                    }
                } catch (e) { /* Intl API not supported */ }
                
                try {
                    const userLang = navigator.language;
                    if (!userLang) {
                        flags.push('FLAG_LANGUAGE_MISMATCH');
                    }
                } catch (e) { /* navigator.language not supported */ }

                return flags;
            }

            _calculateTrustScore(flags) {
                let score = 0;
                const uniqueFlags = [...new Set(flags)];
                for (const flag of uniqueFlags) {
                    score += (this.riskWeights[flag] || 0);
                }
                return Math.min(score, 100);
            }

            _getCurrentPosition() {
                return new Promise((resolve, reject) => {
                    if (!navigator.geolocation) {
                        return reject(this._createError('Geolocation is not supported.', -1));
                    }
                    navigator.geolocation.getCurrentPosition(
                        resolve,
                        (err) => reject(this._createError(err.message, err.code)),
                        this.locationOptions
                    );
                });
            }

            _getWatchedPositions(n = 5) {
                return new Promise((resolve, reject) => {
                    if (!navigator.geolocation) {
                        return reject(this._createError('Geolocation is not supported.', -1));
                    }

                    const positions = [];
                    let watchId;

                    const success = (position) => {
                        positions.push(position);
                        if (positions.length >= n) {
                            navigator.geolocation.clearWatch(watchId);
                            resolve(positions);
                        }
                    };

                    const error = (err) => {
                        navigator.geolocation.clearWatch(watchId);
                        if (positions.length > 0) {
                            resolve(positions);
                        } else {
                            reject(this._createError(err.message, err.code));
                        }
                    };

                    watchId = navigator.geolocation.watchPosition(success, error, this.locationOptions);
                    
                    setTimeout(() => {
                        if (watchId) {
                            navigator.geolocation.clearWatch(watchId);
                            if (positions.length > 0) {
                                resolve(positions);
                            } else {
                                // Fallback to getCurrentPosition
                                this._getCurrentPosition()
                                    .then(pos => resolve([pos]))
                                    .catch(fallbackErr => {
                                        const code = fallbackErr.code || 3;
                                        const message = `watchPosition timed out, and fallback failed: ${fallbackErr.message}`;
                                        reject(this._createError(message, code));
                                    });
                            }
                        }
                    }, this.locationOptions.timeout);
                });
            }

            _haversine(coords1, coords2) {
                const toRad = (x) => x * Math.PI / 180;
                const dLat = toRad(coords2.latitude - coords1.latitude);
                const dLon = toRad(coords2.longitude - coords1.longitude);
                const lat1 = toRad(coords1.latitude);
                const lat2 = toRad(coords2.latitude);
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                        Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return this.EARTH_RADIUS_KM * c * 1000;
            }
            
            _calculateStdDev(arr) {
                if (!arr || arr.length === 0) return 0;
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                const variance = arr.reduce((a, b) => a + (b - mean) ** 2, 0) / arr.length;
                return Math.sqrt(variance);
            }
        }
    </script>

    <!-- 
      ==================================================================
      SCRIPT: Test Page Logic
      ==================================================================
    -->
    <script>
        // Get references to all our DOM elements
        const runTestButton = document.getElementById('runTestButton');
        const resultsContainer = document.getElementById('resultsContainer');
        const loader = document.getElementById('loader');
        const errorMessage = document.getElementById('errorMessage');
        const errorText = document.getElementById('errorText');
        const successResults = document.getElementById('successResults');
        const scoreEl = document.getElementById('score');
        const scoreDescriptionEl = document.getElementById('scoreDescription');
        const flagsListEl = document.getElementById('flagsList');
        const fullReportEl = document.getElementById('fullReport');
        const resultBox = document.getElementById('fullReport');

        // Main function to run the test
        async function runTest() {
            // 1. Reset UI
            resultsContainer.classList.remove('hidden');
            loader.classList.remove('hidden');
            successResults.classList.add('hidden');
            errorMessage.classList.add('hidden');
            runTestButton.disabled = true;
            runTestButton.textContent = 'Analyzing...';
            resultBox.classList.remove('high-risk', 'medium-risk', 'low-risk');

            try {
                // 2. Run Analyzer
                const analyzer = new LocationTrustAnalyzerLite();
                const result = await analyzer.checkLocationTrust();

                // 3. Display Results
                displaySuccess(result);

            } catch (error) {
                // 4. Display Error (This is a fallback for unhandled errors)
                console.error("Unhandled error in runTest:", error);
                displayError("An unexpected error occurred: " + error.message);
            } finally {
                // 5. Final UI state
                loader.classList.add('hidden');
                runTestButton.disabled = false;
                runTestButton.textContent = 'Run Analysis Again';
            }
        }
        
        function displaySuccess(result) {
            // Check for analysis errors (like permission denied)
            if (result.flags.some(flag => flag.startsWith('FLAG_ERROR_'))) {
                const errorFlag = result.flags.find(flag => flag.startsWith('FLAG_ERROR_'));
                let message = result.data.error || 'Unknown analysis error.';
                
                // Use the code to give a better message
                switch(errorFlag) {
                    case 'FLAG_ERROR_PERMISSION_DENIED':
                        message = 'Geolocation permission was denied. We cannot analyze the location.';
                        break;
                    case 'FLAG_ERROR_TIMEOUT':
                        message = 'Geolocation timed out. Could not get an accurate position.';
                        break;
                    case 'FLAG_ERROR_POSITION_UNAVAILABLE':
                         message = 'Position is unavailable. This may be due to a weak GPS signal or network issue.';
                         break;
                    case 'FLAG_ERROR_GEOLOCATION_UNSUPPORTED':
                        message = 'Geolocation is not supported by this browser.';
                        break;
                    case 'FLAG_ERROR_ANALYSIS_FAILED':
                        message = `Analysis failed: ${result.data.error}`;
                        break;
                }
                displayError(message);
                return;
            }

            // --- Show Success UI ---
            successResults.classList.remove('hidden');
            
            // --- 1. Score ---
            scoreEl.textContent = result.score;
            let riskClass = 'low-risk';
            if (result.score === 0) {
                scoreDescriptionEl.textContent = 'Looks Good';
                scoreEl.style.color = '#48bb78'; // green-500
                riskClass = 'low-risk';
            } else if (result.score <= 40) {
                scoreDescriptionEl.textContent = 'Suspicious';
                scoreEl.style.color = '#f6e05e'; // yellow-300
                riskClass = 'medium-risk';
            } else {
                scoreDescriptionEl.textContent = 'High Risk';
                scoreEl.style.color = '#e53e3e'; // red-500
                riskClass = 'high-risk';
            }
            resultBox.classList.add(riskClass);

            // --- 2. Flags ---
            flagsListEl.innerHTML = ''; // Clear list
            if (result.flags.length === 0) {
                flagsListEl.innerHTML = '<li class="text-gray-500 italic">No flags triggered.</li>';
            } else {
                result.flags.forEach(flag => {
                    const li = document.createElement('li');
                    li.className = 'text-red-400';
                    li.textContent = flag;
                    flagsListEl.appendChild(li);
                });
            }

            // --- 3. Full Report ---
            // Re-format the data for cleaner display
            const displayData = {
                finalScore: result.score,
                finalFlags: result.flags,
                deviceData: {
                    ...result.data.deviceData,
                    position: { // Only show relevant parts of position
                        coords: {
                            latitude: result.data.deviceData.position.coords.latitude,
                            longitude: result.data.deviceData.position.coords.longitude,
                            accuracy: result.data.deviceData.position.coords.accuracy,
                            speed: result.data.deviceData.position.coords.speed,
                        },
                        timestamp: new Date(result.data.deviceData.position.timestamp).toISOString()
                    }
                },
                crossFlags: result.data.crossFlags
            };
            fullReportEl.textContent = JSON.stringify(displayData, null, 2);
        }

        function displayError(message) {
            errorMessage.classList.remove('hidden');
            errorText.textContent = message;
            resultBox.classList.add('high-risk');
        }

        // Add event listener to the button
        runTestButton.addEventListener('click', runTest);
    </script>
</body>
</html>
